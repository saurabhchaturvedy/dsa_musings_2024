
* Hi. What do you think is a single most important component required for a successful system design interview? What should we focus on the most while preparing for one? I bet this is knowledge. Knowledge of system design concepts and how to combine them together. And let me prove you that by walking you through all the stages of a typical system design interview. This is system design interview channel. And today we discuss how to count things at a large scale. So, the interviewer asks us to design a system that does counting.
* The problem may be articulated clearly, for example we need to count views for videos on Youtube. Or likes on Instagram or Facebook. But more often than that, the problem will be stated in a vague or a more general manner. For example, we may be asked to calculate not a single metric, like number of views, but a set of metrics. For example we need to monitor performance of different applications. Which means we need to count how many requests go through the service, how many errors service produce, average response time.

![img_9.png](img_9.png)

* And of course nothing stops the interviewer from stating the problem in a very generic form, like analyze data in real-time. What does data analysis mean? Who sends us data? Who uses results of this analysis? What real-time really means? These and many other questions need to be clarified. And even if system design problem seems clear to you, let me give you two big reasons why you still need to ask your interviewer questions. The first reason is really important for the interviewer. The second reason is important for you.
* The interviewer wants to see how you deal with ambiguity. Whether you can identify key pieces of the system and define a scope of the problem. And why it is so important for the interviewer - because she wants to understand how you will approach design problems in real life. System design interview problems are usually open-ended. It is impossible to solve such problems within 45 or 60 minutes interview. We should be clear on what functional pieces of the problem we are going to focus till the rest of the interview.
* And why requirements clarification is so important for us, interviewees? Mainly because there may be many solutions to the problem asked. And only when we fully understand what features of the system we need to design, we can come up with a proper set of technologies and building blocks. For example, let's take a problem of counting Youtube video views. If you ask this problem a software engineer with experience in SQL databases, he will explain you why MySQL database is a good fit. Engineer with profound experience in NoSQL databases will explain how to count things
* at large scale using for example Apache Cassandra database. We may use distributed cache to count stuff. Or apply stream processing techniques. Experts in cloud computing will solve this problem using public cloud services only. Engineers focusing on batch processing will solve this problem using for example Hadoop MapReduce. And views counting problem can indeed be solved using all these different approaches. But these options are not equal. Each has its own pros and cons. We should pick those options that address requirements.

![img_10.png](img_10.png)


Requirement Clarification
=========================

What we may want to ask about? My recommendation is to focus on the following 4 big categories: Users, where we want to understand who and how will use the system. Scale, where we want to understand how our system will handle a growing amount of data. Performance, where we want to know how fast our system must be. And cost, where we need to understand budget constraints. Let's see what specific questions in each category we may ask. Here and below we imply views counting system as an example. Who will use the system?

Is this all Youtube viewers who will see the total views count for a video? Or this is a per-hour statistics available to a video owner only? Or may be this total count will be used by some machine learning models to generate recommendations. How the system will be used? The data may be used by marketing department only to generate some monthly reports. In other words data is retrieved not often. Or data is sent to recommendation service in real-time. Meaning that data may be retrieved from the system with a very high pace.

Questions in this category help us understand what data we store in the system. Questions in the Scale category should give us a clue how much data is coming to the system and how much data is retrieved from the system. So, the questions we should ask: How many read queries per second the system needs to process. How much data is queried per request. How many video views per second are processed by the system. Should we deal with sudden traffic spikes and how big they may be. The interviewer will help us define these numbers.

Or we may assume some reasonable values. Questions in the performance category should help us quickly evaluate different design options. For example, if we can count views several hours later than these views actually happened, both batch data processing and stream processing design options can be considered. But if time matters and we need to count views on the fly, or in other words in real-time, batch data processing is not an option. It is just too slow. Another good question to ask, is to clarify how fast data must be retrieved from the system.

![img_11.png](img_11.png)

* And if interviewer tells us that response time must be as small as possible, it's a hint that we must count views when we write data and we should do minimal or no counting when we read data. In other words data must already be aggregated. And questions in the cost category should help us evaluate technology stack. For example, if asked to minimize development cost, we should be leaning towards well-regarded open-source frameworks. And if future maintenance cost is a primary concern, we should consider public cloud services
* for our design. Here is a little secret you might already know. During requirements clarification interviewer starts to understand your level of expertise in systems design. As with coding interviews, if you do not ask questions, this is a warning sign for the interviewer. And here is my advice: think along 4 categories mentioned here, think about data - what data, how it gets in and gets out of the system, and do not worry about time too much. You better spend additional 5 minutes clarifying requirements and scope than find yourself
* solving a different or more complex problem than the interviewer actually asked. The end goal of requirements clarification discussions is to get us closer to defining both functional and non-functional requirements. When we say functional requirements, we mean system behavior, or more specifically APIs - a set of operations the system will support. This is what our system will do. And when we say non-functional requirements, we mean system qualities, such as fast, fault-tolerant, secure. This is basically how a system is supposed to be.
* Let's define functional requirements first. And here is my practical advice. After figuring out what the system should do, you write it down on the whiteboard. In a few sentences. For example, we write down that the system has to count video view events. Count view events is the actual action the system performs and video becomes the input parameter. And if we want the system to calculate not just views, but a broader set of events, let's say likes and shares, we may generalize our API a bit and introduce event type parameter.
* This parameter indicates type of the event we process. We can go one step further and make the system calculate not only count function, but other functions as well, like sum and average. By supporting sum function we can calculate such metric as "total watch time" for a video. While average function can help us calculate average view duration. And we can even further generalize the API and say that the system will not just process events one by one, but a list of events as a single batch. Where each event is an object that contains information about a video, type of the event,
* time when event happened and so forth. Similar thought process can be applied for data retrieval API. We first write down something like: the system has to return video views count for a time period. Get views count becomes an action. While video identifier and start and end time become input parameters. If we want to retrieve count not only for video views, but for likes and dislikes for example, we can introduce event type parameter. And if we want our API return not just count statistics, but also statistics for sum and
* average, we should specify function as a parameter and name our API in a more generic way, like getStats. Following this simple technique will help you identify names of APIs, input parameters and, if needed, make several iterations to generalize APIs. Now, let's talk about non-functional requirements. Usually, the interviewer will not tell us specific non-functional requirements. Most likely, she will challenge us with mentioning big scale and high performance, as it is hard to achieve both at the same time.
* And we will need to find tradeoffs. In one of the previous videos I recommended to focus on scalability, performance and availability as top priority requirements. Let's use them here. We need to design a system that should handle tens of thousands of requests per second. We also want view count statistic to be returned in a matter of few tens of milliseconds. And we want view count statistics to be shown to users all the time. Even when there are network or hardware failures in the system. Although these 3 will be our primary concern, let's also talk about two other interesting

![img_12.png](img_12.png)

* requirements. Let's recall a CAP theorem and talk about consistency a bit. And I would like us to touch a cost minimization topic. And my advice is that you write down non-functional requirements on the whiteboard as well. It will help you later while choosing among several design options. We will talk more about this. Now, we have come to the next stage of a system design interview: high-level architecture. And we will start with something really simple. We need a database to store data. We will have a web service that processes incoming video view events and stores data

![img_13.png](img_13.png)

* in the database. To retrieve view counts from the database, let's introduce another web service. Nothing scary so far, right? And it should not be. At this point we do not yet have a clear vision of all pieces of the design. So, we just throw some very high-level components to the whiteboard. But what do we do next? High chances the interviewer is an expert in the field and knows the question very well. And she may start asking questions about any component we outlined in the high-level architecture.
* But we may not feel comfortable discussing any component just yet. Unless you are an expert in this field yourself, the whole picture may not yet be clear to you. This is in our best interest as interviewees to drive the conversation and move forward one step at a time. This is like assembling a puzzle. The interviewer can assemble the puzzle starting from any color group. But we need to start with something simple and construct the frame with the outside pieces first. So, what is this frame of outside pieces of a system design puzzle?
* It's data. And more specifically we need to think what data we want to store and how. Or using more professional terms we need to define a data model. We have two options for what data we want to store. We may store each individual video view event. Or we may calculate views on the fly and store aggregated data. When we store individual events we capture all attributes of the event: video identifier, timestamp, user related information such as country, device type, operating system and so on. When we aggregate data we calculate a total count per some time interval, let's say one

![img_14.png](img_14.png)

* minute and we lose details of each individual event. There are pros and cons of each option. Individual events can be stored really fast. We just get the event and push it to the database. Later, when we retrieve data, we can slice and dice data however we want. We can filter based on specific attributes, aggregate based on some rules. And if there was a bug in some business report, we can recalculate numbers from scratch. But there are drawbacks of this approach. We cannot read data quickly. We need to count each individual event when total count is requested.
* This takes time. Another big disadvantage of this approach - it may cost a lot of money to store all the raw events. Youtube generates billions of view events per day. Raw events storage must be huge. On the other hand, reads become fast when we aggregate data. We do not need to calculate each individual event, we just retrieve total count value. Another nice property of the aggregated data, we can use it for decision making in real-time. For example, we may send the total count value to a recommendation service or trending service,
* for popular videos to be promoted to trends. Aggregated data approach has drawbacks as well. First of all, we can only query data the way it was aggregated. Ability to filter data or aggregate it differently is very limited. This approach also requires us to implement data aggregation pipeline. We need to somehow pre-aggregate data in memory before storing it in the database. This is not an easy task and later you will see why. Another big problem with this approach, it is hard or even impossible to fix errors.
* Let's say we introduced a bug in the aggregation logic. Then, how do we fix total counts after the bug was fixed? So, which option should we chose? Store raw events or aggregate data in real-time? This is where we need interviewer to help us make a decision. We should ask the interviewer about expected data delay. Time between when event happened and when it was processed. If it should be no more than several minutes - we must aggregate data on the fly. If several hours is ok, then we can store raw events and process them in the background.

![img_15.png](img_15.png)

* Former approach is also known as stream data processing, while latter is called batch data processing. The interviewer will let us know what option she is interested the most. But because I have no-one to ask...anybody...no...I will pick both options. And by the way combining both approaches makes a lot of sense for many systems out there. We will store raw events, and because there are so many of them, we will store events for several days or weeks only. And then purge old data. And we will also calculate and store numbers in real-time.
* So that statistics is available for users right away. By storing both raw events and aggregated data we get the best of both worlds: fast reads, ability to aggregate data differently and re-calculate statistics if there were bugs or failures on a real-time path. But there is a price to pay for all this flexibility, the system becomes more complex and expensive. Great topic to discuss with the interviewer. Further in this video we will mainly focus on real-time aggregation option. As I find it more educational from the system design perspective.
* Now let's talk about where we store the data. The interviewer wants to know specific database name and why we make this choice. We should know (and do not worry if you do not know, you will know it in details in several minutes) that both SQL and NoSQL databases can scale and perform well. So, we may want to evaluate both options. And here is where we should recall non-functional requirements. Remember that we wrote them down on the whiteboard before, right? What are those? Scalability, performance and availability.

Where we store data ?
===========================


![img_16.png](img_16.png)

* So, we should evaluate databases against these requirements. And let's add some more requirements along the way. Feel free to use this list for other interview questions and system design in general. Database solution we chose should scale well for both reads and writes. It should be fast and guarantee high availability. We should be able to achieve required level of data consistency. We should understand how to recover data, achieve security, apply future data model changes. We need to pick hardware and evaluate cost of the solution.
* First, let's see how SQL databases handle these requirements. Things are simple when we can store all our data on a single database machine. But when a single machine is not enough, we need to introduce more machines and split data between them. This procedure is called sharding or horizontal partitioning. Each shard stores a subset of all the data. And because we now have several machines, services that talk to the database need to know how many machines exist and which one to pick to store and retrieve data.
* We discussed before that we have Processing service, that stores data in the database and Query service, that retrieves data from the database. We could have made both these services to call every database machine directly. A better option is to introduce a light proxy server that knows about all database machines and routes traffic to the correct shard. Now, both Processing and Query services talk to this cluster proxy only. They do not need to know about each and every database machine anymore.

* But cluster proxy has to know. Moreover, proxy needs to know when some shard dies or become unavailable due to network partition. And if new shard has been added to the database cluster, proxy should become aware of it. How do we achieve this? We introduce a new component - Configuration service. Configuration service maintains a health check connection to all shards. So, it always knows what database machines are available. So, cluster proxy calls a particular shard. And instead of calling database instance directly, we can introduce one more proxy - shard proxy,
* that sits in front of a database. Shard proxy will help us in many different ways: it can cache query results, monitor database instance health and publish metrics, terminate queries that take too long to return data and many more. Great, this setup helps us address several requirements we mentioned before. Like scalability and performance. But availability is not yet addressed. What if database shard died? How to make sure data is not lost? I believe you already know the answer to this question.
* We need to replicate data. Let's call each existing shard a master shard or a leader. And for every master shard we introduce a copy of it, called read replica or a follower. We call it read replica because writes still go through a master shard, but reads may go through both master shard and a replica. We also put some replicas to a data center different from their master shard. So that if the whole data center goes down, we still have a copy of data available. So, when store data request comes, based on the information provided by Configuration
* service, cluster proxy sends data to a shard. And data is either synchronously or asynchronously replicated to a corresponding read replica. And when retrieve data request comes, cluster proxy may retrieve data either from a master shard or from a read replica. Ideas we have just discussed is what Youtube is actually using. They have built a database solution to scale and manage large clusters of MySQL instances. It is called Vitess. Great, we now know how to scale SQL databases. But this solution does not seem simple, right.
* We have all these proxies, configuration service, leader and replica instances. May be we can simplify things a little bit. Let's take a look at what NoSQL databases can offer us. And more specifically, Apache Cassandra database. In NoSQL world we also split data into chunks - shards, also known as nodes. But instead of having leaders and followers we say that each shard is equal. We no longer need configuration service to monitor health of each shard. Instead, let's allow shards talk to each other and exchange information about their state.

![img_17.png](img_17.png)

* To reduce network load, we do not need each shard to talk to every other shard. Every second shard may exchange information with a few other shards, no more than 3. Quickly enough state information about every node propagates throughout the cluster. This procedure is called a gossip protocol. Ok, each node in the cluster knows about other nodes. And this is a big deal. Remember that previously we used Cluster Proxy component to route requests to a particular shard. As Cluster Proxy was the only one who knew about all shards.

No-SQL Databases
=====================

* But now every node knows about each other. So, clients of our database no longer need to call a special component for routing requests. Clients may call any node in the cluster and node itself will decide where to forward this request further. Let's elaborate on this. Processing service makes a call to store views count for some video B. And let's say node 4 is selected to serve this request. We can use a simple round robin algorithm to chose this initial node, or we may be smarter and chose a node that is "closest" to the client in terms of network distance.
* Let's call this node 4 a coordinator node. The coordinator node needs to decide which node stores data for the requested video. We can use consistent hashing algorithm to pick the node. As you may see node 1 should store the data for the video B. Coordinator node will make a call to the node 1 and wait for the response. Actually, nothing stops coordinator node to call multiple nodes to replicate data, for example 3 nodes if we want 3 copies of data. Waiting for 3 responses from replicas may be too slow, so we may consider the write
* to be successful as soon as only 2 replication requests succeeded. This approach is called quorum writes. Similar to quorum writes, there is a quorum reads approach. When Query service retrieves views count for video B, coordinator node 4 will initiate several read requests in parallel. In theory, the coordinator node may get different responses from replica nodes. Why? Because some node could have been unavailable when write request happened. That node has stale data right now, other 2 nodes has up-to-date data.
